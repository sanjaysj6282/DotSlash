#include <bits/stdc++.h>
using namespace std;

#define FAST {ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);}

#define ll long long int
#define ld long double

#define pb push_back 
#define pi pair<ll, ll>
#define ff first
#define ss second
#define vi vector<ll> 
#define vb vector<bool>
#define vii vector<pi>
#define vvi vector<vi> 
#define mii map<ll, ll>
#define rep(i,a,b) for(ll i=a; i<b; i++)
#define srt(v) sort(v.begin(), v.end(), greater<ll>())
#define setcnt(n) __builtin_popcount(n) // no of ones(set bits)
#define bitcnt(n) (int)log2(n) // no of bits

#define yy cout<<"YES\n"
#define nn cout<<"NO\n"
#define pre(a) {cout << fixed << setprecision(a);}
#define vect(v, n) {rep(i, 0, n){ll x; cin>>x; v.pb(x);}}

const int M=1e4+3, MOD=1e9+7;

ll gcd(ll a,ll b) {if(b==0) return a; return gcd(b,a%b); }
ll lcm(ll a,ll b) {return a/gcd(a,b)*b; }

/*
Editorial

The following editorial explains an approach for solving this problem.

In this problem you are asked to help Ashwin maximize the number of Samosas that could be made. Another way of looking at this is to try to minimize the number of unused ingredients. We will take this later approach, considering first the pairings of Samosa fillings that could be used. The approach presented here is significantly simpler than the iterative approaches that most teams tried.

Let r be the number of Radish servings, m be the number of meat servings, and b be the number of bean servings. Furthermore, let:

x = min(r, m, b), i.e. the smallest quantity of all fillings

y = median(r, m, b), i.e. the middle quantity of all fillings

z = max(r, m, b), i.e. the largest quantity of all fillings

We will refer to x-type, y-type, and z-type ingredients to mean the type of the corresponding filling.

Scenario 1: z > x + y

Here the maximum number of filling combinations we can create is generated by using the z-type filling in every Samosa, with one of the other fillings. So if s is the number of Samosa shells we have, the number of Samosas Ashwin can make is the min(s, x + y).

Scenario 2: z <= x + y

In scenario 2, we will take an approach that, given sufficient Samosa shells, will use all but at most one of the fillings. We will start by making Samosas with the x-type filling and the z-type filling, reducing z until it becomes equal with y.

Then, while there are still two x-type fillings remaining, we will make two Samosas - one with x-type and y-type fillings, and one with x-type and z-type fillings. By making pairs of Samosas at a time, y stays equal to z.

Once we down to less than 2 remaining x-type fillings, we will make Samosas using y-type and z-type fillings. Since there are an equal number of both of these, we can use all of the y-type and z-type ingredients.

Since we know how to use all (but perhaps one) of the ingredients in this case, we can come up with a simple formula for the number of Samosas. Letting s be the number of Samosa shells we have, the number of Samosas Ashwin can make is the min(s, floor((x + y + z)/2)).

Note: In this second formula, we are adding three numbers that could be as large as 109. The result could be a number greater than 231-1, and so, you cannot use a 32-bit integer to store this value. You will fail test case 2, if you fail to account for this.
*/

void solve(){
    ll s, m, r, b;
    cin >> s>> m>> r>> b;

    // vi v;
    // v.pb(m); v.pb(r); v.pb(b);

    // srt(v);

    // // cout << v[0] << v[1] << v[2] << endl;

    // ll ans=0;
    // ans+=v[1];
    // v[0]-=v[1];
    // v[1]=0;
    // if(v[0]>=v[2]){
    //     ans+=v[2];
    // }

    // cout << min(ans, s) << endl;
    ll x=min(r, min(m, b));
    ll z=max(r, max(m, b));
    ll y=m+r+b-x-z;

    if(z>(x+y)){
        // cout << x << y << endl;
        cout << min(s, (x+y)) << endl;
    }
    else{
        ll k=floor((x + y + z)/2);
        cout << min(s, k) << endl;
    }

    // 6 4 1 
}

int32_t main() {
    FAST;

    ll t=1;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}